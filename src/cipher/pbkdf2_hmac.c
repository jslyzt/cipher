#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "pbkdf2_hmac.h"
#include "sha.h"
#define KEY_IOPAD_SIZE 64
#define PUT_32BIT_MSB_FIRST(cp, value) ( \
    (cp)[0] = (unsigned char)((value) >> 24), \
    (cp)[1] = (unsigned char)((value) >> 16), \
    (cp)[2] = (unsigned char)((value) >> 8), \
    (cp)[3] = (unsigned char)(value))

typedef struct {
    SHA_State ctx;

    unsigned char ipad[KEY_IOPAD_SIZE]; /*!< HMAC: inner padding */
    unsigned char opad[KEY_IOPAD_SIZE]; /*!< HMAC: outer padding */
} sha1_context;

void sha1_hmac_starts(sha1_context * ctx, const unsigned char *key, int keylen)
{
    int i;
    unsigned char sum[20];

    if (keylen > 64) {
        SHA_Simple(key, keylen, sum);
        keylen = 20;
        key = sum;
    }

    memset(ctx->ipad, 0x36, KEY_IOPAD_SIZE);
    memset(ctx->opad, 0x5C, KEY_IOPAD_SIZE);

    for (i = 0; i < keylen; i++) {
        ctx->ipad[i] = (unsigned char)(ctx->ipad[i] ^ key[i]);
        ctx->opad[i] = (unsigned char)(ctx->opad[i] ^ key[i]);
    }

    SHA_Init(&ctx->ctx);
    SHA_Bytes(&ctx->ctx, ctx->ipad, KEY_IOPAD_SIZE);

}

/*
* SHA-1 HMAC process buffer
*/
void sha1_hmac_update(sha1_context * ctx, const unsigned char *input, int ilen)
{
    SHA_Bytes(&ctx->ctx, input, ilen);
}

/*
* SHA-1 HMAC final digest
*/
void sha1_hmac_finish(sha1_context * ctx, unsigned char output[20])
{
    unsigned char tmpbuf[20];

    SHA_Final(&ctx->ctx, tmpbuf);
    SHA_Init(&ctx->ctx);
    SHA_Bytes(&ctx->ctx, ctx->opad, 64);
    SHA_Bytes(&ctx->ctx, tmpbuf, 20);
    SHA_Final(&ctx->ctx, output);

}
#ifndef min
#define min( a, b ) ( ((a) < (b)) ? (a) : (b) )
#endif

void PKCS5_PBKDF2_HMAC(const unsigned char *password, size_t plen,
    const unsigned char *salt, size_t slen,
    const unsigned long iteration_count, const unsigned long key_length,
    unsigned char *output)
{
    sha1_context ctx;
    SHA_Init(&ctx.ctx);

	// Size of the generated digest
	unsigned char md_size = 20;
	unsigned char md1[20];
	unsigned char work[20];

	unsigned long counter = 1;
	unsigned long generated_key_length = 0;
	while (generated_key_length < key_length) {
		// U1 ends up in md1 and work
		unsigned char c[4];
        PUT_32BIT_MSB_FIRST(c, counter);
        sha1_hmac_starts(&ctx, password, plen);
        sha1_hmac_update(&ctx, salt, slen);
        sha1_hmac_update(&ctx, c, 4);
        sha1_hmac_finish(&ctx, md1);
		memcpy(work, md1, md_size);

		unsigned long ic = 1;
		for (ic = 1; ic < iteration_count; ic++) {
			// U2 ends up in md1
            sha1_hmac_starts(&ctx, password, plen);
            sha1_hmac_update(&ctx, md1, md_size);
            sha1_hmac_finish(&ctx, md1);
			// U1 xor U2
			unsigned long i = 0;
			for (i = 0; i < md_size; i++) {
				work[i] ^= md1[i];
			}
			// and so on until iteration_count
		}

		// Copy the generated bytes to the key
		unsigned long bytes_to_write =
		    min((key_length - generated_key_length), md_size);
		memcpy(output + generated_key_length, work, bytes_to_write);
		generated_key_length += bytes_to_write;
		++counter;
	}
}

#include "sha256.h"

// for SHA256 HMAC
typedef struct {
    SHA256_State ctx;

    unsigned char ipad[KEY_IOPAD_SIZE]; /*!< HMAC: inner padding */
    unsigned char opad[KEY_IOPAD_SIZE]; /*!< HMAC: outer padding */
} sha2_context;
#define SHA256_DIGEST_SIZE  32
void sha2_hmac_starts(sha2_context * ctx, const unsigned char *key, int keylen)
{
    int i;
    unsigned char sum[SHA256_DIGEST_SIZE];

    if (keylen > 64) {
        SHA256_Simple(key, keylen, sum);
        keylen = SHA256_DIGEST_SIZE;
        key = sum;
    }

    memset(ctx->ipad, 0x36, KEY_IOPAD_SIZE);
    memset(ctx->opad, 0x5C, KEY_IOPAD_SIZE);

    for (i = 0; i < keylen; i++) {
        ctx->ipad[i] = (unsigned char)(ctx->ipad[i] ^ key[i]);
        ctx->opad[i] = (unsigned char)(ctx->opad[i] ^ key[i]);
    }

    SHA256_Init(&ctx->ctx);
    SHA256_Bytes(&ctx->ctx, ctx->ipad, KEY_IOPAD_SIZE);

}

/*
* SHA-2 HMAC process buffer
*/
void sha2_hmac_update(sha2_context * ctx, const unsigned char *input, int ilen)
{
    SHA256_Bytes(&ctx->ctx, input, ilen);
}

/*
* SHA-2 HMAC final digest
*/
void sha2_hmac_finish(sha2_context * ctx, unsigned char output[20])
{
    unsigned char tmpbuf[SHA256_DIGEST_SIZE];

    SHA256_Final(&ctx->ctx, tmpbuf);
    SHA256_Init(&ctx->ctx);
    SHA256_Bytes(&ctx->ctx, ctx->opad, 64);
    SHA256_Bytes(&ctx->ctx, tmpbuf, SHA256_DIGEST_SIZE);
    SHA256_Final(&ctx->ctx, output);

}

void PKCS5_PBKDF2_HMAC2(const unsigned char *password, size_t plen,
    const unsigned char *salt, size_t slen,
    const unsigned long iteration_count, const unsigned long key_length,
    unsigned char *output)
{
    sha2_context ctx;
    SHA256_Init(&ctx.ctx);

    // Size of the generated digest
    unsigned char md_size = SHA256_DIGEST_SIZE;
    unsigned char md1[SHA256_DIGEST_SIZE];
    unsigned char work[SHA256_DIGEST_SIZE];

    unsigned long counter = 1;
    unsigned long generated_key_length = 0;
    while (generated_key_length < key_length) {
        // U1 ends up in md1 and work
        unsigned char c[4];
        PUT_32BIT_MSB_FIRST(c, counter);
        sha2_hmac_starts(&ctx, password, plen);
        sha2_hmac_update(&ctx, salt, slen);
        sha2_hmac_update(&ctx, c, 4);
        sha2_hmac_finish(&ctx, md1);
        memcpy(work, md1, md_size);

        unsigned long ic = 1;
        for (ic = 1; ic < iteration_count; ic++) {
            // U2 ends up in md1
            sha2_hmac_starts(&ctx, password, plen);
            sha2_hmac_update(&ctx, md1, md_size);
            sha2_hmac_finish(&ctx, md1);
            // U1 xor U2
            unsigned long i = 0;
            for (i = 0; i < md_size; i++) {
                work[i] ^= md1[i];
            }
            // and so on until iteration_count
        }

        // Copy the generated bytes to the key
        unsigned long bytes_to_write =
            min((key_length - generated_key_length), md_size);
        memcpy(output + generated_key_length, work, bytes_to_write);
        generated_key_length += bytes_to_write;
        ++counter;
    }
}

#include "sha512.h"
// for SHA512 HMAC
typedef struct {
    SHA512_State ctx;

    unsigned char ipad[KEY_IOPAD_SIZE]; /*!< HMAC: inner padding */
    unsigned char opad[KEY_IOPAD_SIZE]; /*!< HMAC: outer padding */
} sha5_context;
#define SHA512_DIGEST_SIZE  64
void sha5_hmac_starts(sha5_context * ctx, const unsigned char *key, int keylen)
{
    int i;
    unsigned char sum[SHA512_DIGEST_SIZE];

    if (keylen > 64) {
        SHA512_Simple(key, keylen, sum);
        keylen = SHA512_DIGEST_SIZE;
        key = sum;
    }

    memset(ctx->ipad, 0x36, KEY_IOPAD_SIZE);
    memset(ctx->opad, 0x5C, KEY_IOPAD_SIZE);

    for (i = 0; i < keylen; i++) {
        ctx->ipad[i] = (unsigned char)(ctx->ipad[i] ^ key[i]);
        ctx->opad[i] = (unsigned char)(ctx->opad[i] ^ key[i]);
    }

    SHA512_Init(&ctx->ctx);
    SHA512_Bytes(&ctx->ctx, ctx->ipad, KEY_IOPAD_SIZE);

}

/*
* SHA-2 HMAC process buffer
*/
void sha5_hmac_update(sha5_context * ctx, const unsigned char *input, int ilen)
{
    SHA512_Bytes(&ctx->ctx, input, ilen);
}

/*
* SHA-2 HMAC final digest
*/
void sha5_hmac_finish(sha5_context * ctx, unsigned char output[20])
{
    unsigned char tmpbuf[SHA512_DIGEST_SIZE];

    SHA512_Final(&ctx->ctx, tmpbuf);
    SHA512_Init(&ctx->ctx);
    SHA512_Bytes(&ctx->ctx, ctx->opad, 64);
    SHA512_Bytes(&ctx->ctx, tmpbuf, SHA512_DIGEST_SIZE);
    SHA512_Final(&ctx->ctx, output);

}

void PKCS5_PBKDF2_HMAC5(const unsigned char *password, size_t plen,
    const unsigned char *salt, size_t slen,
    const unsigned long iteration_count, const unsigned long key_length,
    unsigned char *output)
{
    sha5_context ctx;
    SHA512_Init(&ctx.ctx);

    // Size of the generated digest
    unsigned char md_size = SHA512_DIGEST_SIZE;
    unsigned char md1[SHA512_DIGEST_SIZE];
    unsigned char work[SHA512_DIGEST_SIZE];

    unsigned long counter = 1;
    unsigned long generated_key_length = 0;
    while (generated_key_length < key_length) {
        // U1 ends up in md1 and work
        unsigned char c[4];
        PUT_32BIT_MSB_FIRST(c, counter);
        sha5_hmac_starts(&ctx, password, plen);
        sha5_hmac_update(&ctx, salt, slen);
        sha5_hmac_update(&ctx, c, 4);
        sha5_hmac_finish(&ctx, md1);
        memcpy(work, md1, md_size);

        unsigned long ic = 1;
        for (ic = 1; ic < iteration_count; ic++) {
            // U2 ends up in md1
            sha5_hmac_starts(&ctx, password, plen);
            sha5_hmac_update(&ctx, md1, md_size);
            sha5_hmac_finish(&ctx, md1);
            // U1 xor U2
            unsigned long i = 0;
            for (i = 0; i < md_size; i++) {
                work[i] ^= md1[i];
            }
            // and so on until iteration_count
        }

        // Copy the generated bytes to the key
        unsigned long bytes_to_write =
            min((key_length - generated_key_length), md_size);
        memcpy(output + generated_key_length, work, bytes_to_write);
        generated_key_length += bytes_to_write;
        ++counter;
    }
}